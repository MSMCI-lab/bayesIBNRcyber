---
title: "Bayesian IBNR Model for Cyber Incidents"
output: github_document
---

```{r setup, echo=TRUE}
# Clear the workspace and load necessary libraries
rm(list = ls())
library(nimble)
library(coda)
library(doParallel)
library(reshape2)
library(ggplot2)
registerDoParallel(cores = 3)  # Adjust number of cores as needed
```

## Introduction

This R Markdown file provides an implementation of a Bayesian Incurred But Not Reported (IBNR) model for cyber incidents in the healthcare industry. The model estimates delayed reporting of incidents based on historical data.

## Data Preparation

```{r}
# Load data and limit to the date range needed
itrc23 <- read.csv("itrc23_healthcare.csv", header = TRUE)[, -1]

# Subset data for the model
breach <- itrc23[1:60, -14]  # 60 rows (time periods), 12 delay periods (we remove the last column, i.e., the delayed month>=12)

# Mask future values for prediction (NA for rows 50-60)
for (i in 50:60) {
  for (j in (63 - i):13) {
    breach[i, j] <- NA
  }
}

```
## Model Setup

This section defines the Bayesian IBNR model using the nimble package.
```{r}
# Define constants and data for nimble
y <- breach[, -1]
nT <- 60
nD <- 12
Consts <- list(nT = nT, nD = nD)
nimbleData <- list(y = as.matrix(y))

# Define nimble model code
nbModel <- nimbleCode({
  for (t in 1:nT) {
    for (d in 1:nD) {
      logit(pmatrix[t, d]) <- beta[1] + beta[2] * t + beta[3] * d / nD
      log(lambda[t, d]) <- g[1] + g[2] * t + g[3] * d / nD
      y[t, d] ~ dnegbin(prob = pmatrix[t, d], size =lambda[t,d])
    }
  }

  # Priors for g and beta coefficients
  g[1] ~ dnorm(0, sig[1])
  g[2] ~ dnorm(0, sig[2])
  g[3] ~ dnorm(0, sig[3])
  beta[1] ~ dnorm(0, sig[4])
  beta[2] ~ dnorm(0, sig[5])
  beta[3] ~ dnorm(0, sig[6])
  
  # Exponential priors for sigma
  for (i in 1:6) {
    sig[i] ~ dexp(rate = 1)
  }
})
```
## MCMC Setup and Execution

We run MCMC with three parallel chains for better convergence.
```{r}
# Initialize model parameters and data list for nimble
constants <- list(nT = nT, nD = nD)
data_list <- list(y = y)
inits <- list(y = y, g = rnorm(3), beta = rnorm(3), sig = rep(1, 6))

# Compile the model and set up MCMC
model <- nimbleModel(code = nbModel, constants = constants, data = data_list, inits = inits)
compiled_model <- compileNimble(model)
mcmc_config <- configureMCMC(model, monitors = c("g", "beta", "y", "sig"))
compiled_mcmc <- compileNimble(buildMCMC(mcmc_config), project = model)

# Set up parallel processing
num_cores <- detectCores() - 1
registerDoParallel(cores = num_cores)
seed <- c(100,229,3098)

# Run MCMC with parallel chains
chains <- foreach(chain = 1:3, .packages = c("nimble", "coda")) %dopar% {
  # Run the MCMC for each chain
  chain_samples <- runMCMC(compiled_mcmc, setSeed=seed[chain], nchains = 1, nburnin=1e+5,niter=5e+5, thin = 100, samplesAsCodaMCMC = TRUE)
  # Convert to mcmc object
  as.mcmc(chain_samples)
}

# Combine the separate chains into an mcmc.list
samples <- mcmc.list(chains)


# Save MCMC results
save(samples, file = "MCMC_results.RData")


```

## Results Analysis
```{r}
# Analyze and visualize results

results1=samples[,c("beta[1]","beta[2]","beta[3]","g[1]","g[2]","g[3]", paste0("sig[", 1:6, "]"))]

summary(results1)

# Traceplot for convergence diagnostics
#pdf("trace_plots.pdf")
traceplot(results1)
#dev.off()

# Gelman-Rubin diagnostic
rhat <- gelman.diag(results1)
print(rhat)
```

## Posterior Prediction
```{r}
# Create an array for posterior predictions
sims.matrix <- do.call(rbind.data.frame, samples)
n.sims <- nrow(sims.matrix)
y_pred_array <- array(dim = c(n.sims, nT, nD))

# Generate predictions for masked future values
for (t in 50:60) {
  for (d in (62 - t):12) {
    y_pred_array[, t, d] <- sims.matrix[[paste0("y[", t, ", ", d, "]")]]
  }
}
```

## prediction matrix
```{r}
# Initialize prediction matrices
pred_median<-breach[,-1]
pred_mean <- pred_median
pred_lower95 <- pred_median
pred_upper95 <- pred_median
pred_upper99 <- pred_median
pred_lower99 <- pred_median

# Populate prediction matrices with quantiles and means from posterior samples
for (i in 50:60) {
  for (j in (62 - i):12) {
    pred_median[i, j] <- median(y_pred_array[, i, j], na.rm = TRUE)
    pred_mean[i, j] <- mean(y_pred_array[, i, j], na.rm = TRUE)
    pred_lower95[i, j] <- quantile(y_pred_array[, i, j], 0.025, na.rm = TRUE)
    pred_upper95[i, j] <- quantile(y_pred_array[, i, j], 0.975, na.rm = TRUE)
    pred_lower99[i, j] <- quantile(y_pred_array[, i, j], 0.005, na.rm = TRUE)
    pred_upper99[i, j] <- quantile(y_pred_array[, i, j], 0.995, na.rm = TRUE)
  }
}

test=itrc23[1:60,-c(1,14)]

# Initialize vectors for storing predictions and real values

pred_mean_vec=rep(NA,66)
pred_median_vec=rep(NA,66)
pred_95upper_vec=rep(NA,66)
pred_95lower_vec=rep(NA,66)
real_vec=rep(NA,66)
s=1
for(i in 50:60){
  for(j in (62-i):12){
    pred_mean_vec[s]= pred_mean[i,j]
    pred_median_vec[s]= pred_median[i,j]
    pred_95upper_vec[s]= pred_upper95[i,j]
    pred_95lower_vec[s]= pred_lower95[i,j]
    real_vec[s]=test[i,j]
    s=s+1
}
}

dall_pred=data.frame(real_vec, pred_mean_vec, pred_median_vec,pred_95lower_vec,pred_95upper_vec)
dall_pred



```
## Visualization of Predictions
```{r}
# Assuming your data frame is named breach and is already loaded
breach$BreachMonth <- as.Date(paste0(breach$BreachMonth, "-01")) # Convert to Date format
colnames(breach) <- gsub("X", "", colnames(breach))

# Melt the data frame for long format
breach_long <- reshape2::melt(breach, id.vars = "BreachMonth")

# Calculate observed, real, and nowcast values
breachobs <- rowSums(breach[50:60, -1], na.rm = TRUE)
realobs <- rowSums(test[50:60, ], na.rm = TRUE)
nowcast <- rowSums(pred_median[50:60, ], na.rm = TRUE)
nowcast95up <- rowSums(pred_upper95[50:60, ], na.rm = TRUE)
nowcast95l <- rowSums(pred_lower95[50:60, ], na.rm = TRUE)

# Define dates for plotting
start_date <- as.Date("2022-02-01")
dates1 <- seq.Date(start_date, by = "month", length.out = length(breachobs))

# Create data frames for observed, real, nowcast, and bounds
obs_points_df <- data.frame(BreachMonth = dates1, value = breachobs, variable = "Observed")
real_points_df <- data.frame(BreachMonth = dates1, value = realobs, variable = "Real")
nowcast_points_df <- data.frame(BreachMonth = dates1, value = nowcast, variable = "Nowcast")
nowcast95up_points_df <- data.frame(BreachMonth = dates1, value = nowcast95up, variable = "95 Upper Bound")
nowcast95l_points_df <- data.frame(BreachMonth = dates1, value = nowcast95l, variable = "95 Lower Bound")

# Filter data for "1m" category
breach_long1m <- breach_long[breach_long$variable == "1m", ]

# Plotting
delayed_pred <- ggplot(breach_long1m[breach_long1m$BreachMonth > as.Date("2021-09-01"), ], 
                       aes(x = BreachMonth, y = value, color = variable, group = variable)) +
  geom_line() +
  geom_point() +
  labs(title = "", x = "", y = "Frequency", color = " ") +
  theme_minimal() +
  theme(
    text = element_text(face = "bold"),  # Bold text for all text elements
    axis.title = element_text(face = "bold", size = 12),  # Bold and slightly larger axis titles
    axis.text = element_text(face = "bold", size = 10),  # Bold axis texts
    legend.title = element_text(face = "bold", size = 10),  # Bold legend title
    legend.text = element_text(face = "bold", size = 8)  # Bold legend texts
  ) +
  scale_x_date(date_labels = "%m/%y", date_breaks = "2 months") +  # Custom month-year format
  geom_vline(xintercept = as.numeric(as.Date("2022-01-01")), linetype = "dashed", color = "black") +
  
  # Add observed, real, and nowcast points with lines
  geom_point(data = obs_points_df, aes(x = BreachMonth, y = value, color = variable), size = 3) +
  geom_line(data = obs_points_df, aes(x = BreachMonth, y = value, color = variable, group = variable)) +
  
  geom_point(data = real_points_df, aes(x = BreachMonth, y = value, color = variable), size = 3) +
  geom_line(data = real_points_df, aes(x = BreachMonth, y = value, color = variable, group = variable)) +
  
  geom_point(data = nowcast_points_df, aes(x = BreachMonth, y = value, color = variable), size = 3) +
  geom_line(data = nowcast_points_df, aes(x = BreachMonth, y = value, color = variable, group = variable)) +

  # Add 95% bounds as separate lines
  geom_line(data = nowcast95up_points_df, aes(x = BreachMonth, y = value, color = variable, group = variable), linetype = "dotted") +
  geom_line(data = nowcast95l_points_df, aes(x = BreachMonth, y = value, color = variable, group = variable), linetype = "dotted")

# plot
print(delayed_pred)

```
## Reserve Estimates and Summary
```{r}
# Calculate reserve estimates
nowcast_r <- rowSums(pred_median[49:60, ], na.rm = TRUE) * 4.35
real_r <- rowSums(test[49:60, ], na.rm = TRUE) * 4.35
paid_r <- rowSums(breach[49:60, -1], na.rm = TRUE) * 4.35

# Summary table
reserve_summary <- data.frame(Estimated = nowcast_r, Paid = paid_r, IBNR = nowcast_r - paid_r, Real = real_r)
print(reserve_summary)
```


